# -*- coding: utf-8 -*-
"""8AndOr.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OVG10d2i29EMYDG2XNv5uF9b0Lzx5h1U
"""

# split the number to maximum power of 2 numbers
def brecking(x):
    powers = []
    i = 1
    while i <= x:
        if i & x:
            powers.append(i)
        i <<= 1
    return powers
def rebrecking(x):
  powers = brecking(x)
  while len(powers) < 8:
    if powers[-1] > 1 :
      powers.append((powers[-1])/2)
      powers.append((powers[-2])/2)
      powers.sort()
      powers.pop()
  return powers

import numpy as np
from itertools import chain

def gen_primes(n, x, y):   #n is the bais number, x is the list of - , y is the list of for indexes
    res = n
    for i in range (0, len(x)):
        if y[i]!= 0:
          res += 2**x[i]
    return res

def group16(primes,x,y):
  ones = np.full(len(x), 1) # cte configures
  loops = np.full(len(y), 0) # need to be calculated
  numbers = []
  #for I in x:
   # ones.append(1)
  bias = gen_primes(0,x,ones)
   
  #numbers.append(n)
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              for g in range(2):
                loops[6] = g
                for h in range(2):
                  loops[7] = h
                  for i in range(2):
                    loops[8] = i
                    for j in range(2):
                      loops[9] = j
                      for k in range(2):
                        loops[10] = k
                        for l in range(2):
                          loops[11] = l
                          for m in range(2):
                            loops[12] = m
                            for n in range(2):
                              loops[13] = n
                              for o in range(2):
                                loops[14] = o
                                for p in range(2):
                                  loops[15] = o
                                  #print (loops)
                                  numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
  #print ("primes : ", prime2)
  #print (len(prime2))
  return prime2

def group15(primes,x,y):
  ones = np.full(len(x), 1) # cte configures
  loops = np.full(len(y), 0) # need to be calculated
  numbers = []
  #for I in x:
   # ones.append(1)
  bias = gen_primes(0,x,ones)
   
  #numbers.append(n)
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              for g in range(2):
                loops[6] = g
                for h in range(2):
                  loops[7] = h
                  for i in range(2):
                    loops[8] = i
                    for j in range(2):
                      loops[9] = j
                      for k in range(2):
                        loops[10] = k
                        for l in range(2):
                          loops[11] = l
                          for m in range(2):
                            loops[12] = m
                            for n in range(2):
                              loops[13] = n
                              for o in range(2):
                                loops[14] = o
                                  #print (loops)
                                numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group14(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  #for I in x:
   # ones.append(1)
  bias = gen_primes(0,x,ones)
   
  #numbers.append(n)
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              for g in range(2):
                loops[6] = g
                for h in range(2):
                  loops[7] = h
                  for i in range(2):
                    loops[8] = i
                    for j in range(2):
                      loops[9] = j
                      for k in range(2):
                        loops[10] = k
                        for l in range(2):
                          loops[11] = l
                          for m in range(2):
                            loops[12] = m
                            for n in range(2):
                              loops[13] = n
                              numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group13(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  #for I in x:
   # ones.append(1)
  bias = gen_primes(0,x,ones)
   
  #numbers.append(n)
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              for g in range(2):
                loops[6] = g
                for h in range(2):
                  loops[7] = h
                  for i in range(2):
                    loops[8] = i
                    for j in range(2):
                      loops[9] = j
                      for k in range(2):
                        loops[10] = k
                        for l in range(2):
                          loops[11] = l
                          for m in range(2):
                            loops[12] = m
                            numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group12(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  #for I in x:
   # ones.append(1)
  bias = gen_primes(0,x,ones)
   
  #numbers.append(n)
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              for g in range(2):
                loops[6] = g
                for h in range(2):
                  loops[7] = h
                  for i in range(2):
                    loops[8] = i
                    for j in range(2):
                      loops[9] = j
                      for k in range(2):
                        loops[10] = k
                        for l in range(2):
                          loops[11] = l
                          numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group11(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  #for I in x:
   # ones.append(1)
  bias = gen_primes(0,x,ones)
   
  #numbers.append(n)
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              for g in range(2):
                loops[6] = g
                for h in range(2):
                  loops[7] = h
                  for i in range(2):
                    loops[8] = i
                    for j in range(2):
                      loops[9] = j
                      for k in range(2):
                        loops[10] = k
                        numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2


def group10(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
   
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              for g in range(2):
                loops[6] = g
                for h in range(2):
                  loops[7] = h
                  for i in range(2):
                    loops[8] = i
                    for j in range(2):
                      loops[9] = j
                      numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2


def group9(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
   
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              for g in range(2):
                loops[6] = g
                for h in range(2):
                  loops[7] = h
                  for i in range(2):
                    loops[8] = i
                    numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group8(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
   
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              for g in range(2):
                loops[6] = g
                for h in range(2):
                  loops[7] = h
                  numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group7(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
   
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              for g in range(2):
                loops[6] = g
                numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group6(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
   
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            for f in range(2):
              loops[5] = f
              numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group5(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
   
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          for e in range(2):
            loops[4] = e
            numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group4(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
   
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        for d in range(2):
          loops[3] = d
          numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group3(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
   
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      for c in range(2):
        loops[2] = c
        numbers.append(gen_primes(bias,y,loops))
  
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group2(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
   
  for a in range(2):
    loops[0] = a
    for b in range(2):
      loops[1] = b
      numbers.append(gen_primes(bias,y,loops))
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group1(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
   
  for a in range(2):
    loops[0] = a
    numbers.append(gen_primes(bias,y,loops))

  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def group0(primes,x,y):
  ones = np.full(len(x), 1)
  loops = np.full(len(y), 0)
  numbers = []
  bias = gen_primes(0,x,ones)
  numbers.append(bias)
  prime2 = primes[:-1]    # sprint ("before : ", primes)
  for i in numbers:
    if i not in prime2:
      prime2.append(i)
 #print ("primes : ", prime2)
 #print (len(prime2))
  return prime2

def call_groups(primes,x,y):
  prime1 =[]
  res =[]
  for i in range(0, len(x)):
    func = "group"+ str(len(y[i]))
    #print (func)
    prime1.append(globals()[func](res,x[i],y[i]))
    #print("prime1 : ", len(prime1))
    #print("prime2 : ", len(prime2))
    flatten_list = list(chain.from_iterable(prime1))
    [res.append(x) for x in flatten_list if x not in res]
    #print(len(res))

  return res
import random
def mk_gr (int_primes, x, flag, numNeq, bits):
  #int_primes = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
  #ind_primes = [ 'a', 'c','e', 'g', 'i', 'k', 'm', 'o', 'b', 'd', 'f', 'h', 'j', 'l', 'n', 'p']
  # 0 is the least significant bit and 20 is the most significant bit
  #int_primes = random.shuffle(l)
  #random.shuffle(int_primes)
  m = []
  notm = []
  notVal = 0
  for i in range (0, len(x)):
    temp = format(i, "b").zfill(3)
    res = [int(x) for x in str(temp)]
    res = res[::-1]
    #print(temp)
    m.append(int_primes[0:x[i]])
    notm.append(int_primes[x[i]:bits])
    temp = format(random.randint(0, 2**(len(m[i])-5)), "b").zfill(len(m[i])-5)
    res2 = [int(x) for x in str(temp)]
    res= res+ res2
    #print(res)
    for j in reversed(range(len(res))):
      if res[j] == 1:
        #print(i, j)
        m[i][j] = "~"+ str(m[i][j])
        #print(m[i][j])
        m[i].pop(j)
        #print(m[i][j])
  return m, notm
  
  
import math
def gen_number(num , bits):
  x = rebrecking(num)
  x = [int(a) for a in x]
  #print(x)
  y = [int(bits-math.log2(a)) for a in x]
  #print (y)
  #primes = list(reversed(range((bits))))
  primes = list(range((bits)))
  m, n = mk_gr (primes, y, 0, 0, bits)
  #print(m)
  #print(n)
  l = call_groups(primes,m,n)
  quine_mccluskey(l)
  return(l)



# Quine McCluskey algorithm for minimizing logical expressions
# Author: Suman Adhikari

def mul(x,y): # Multiply 2 minterms
    res = []
    for i in x:
        if i+"'" in y or (len(i)==2 and i[0] in y):
            return []
        else:
            res.append(i)
    for i in y:
        if i not in res:
            res.append(i)
    return res

def multiply(x,y): # Multiply 2 expressions
    res = []
    for i in x:
        for j in y:
            tmp = mul(i,j)
            res.append(tmp) if len(tmp) != 0 else None
    return res

def refine(my_list,dc_list): # Removes don't care terms from a given list and returns refined list
    res = []
    for i in my_list:
        if int(i) not in dc_list:
            res.append(i)
    return res

def findEPI(x): # Function to find essential prime implicants from prime implicants chart
    res = []
    for i in x:
        if len(x[i]) == 1:
            res.append(x[i][0]) if x[i][0] not in res else None
    return res

def findVariables(x): # Function to find variables in a meanterm. For example, the minterm --01 has C' and D as variables
    var_list = []
    for i in range(len(x)):
        if x[i] == '0':
            var_list.append(chr(i+65)+"'")
        elif x[i] == '1':
            var_list.append(chr(i+65))
    return var_list

def flatten(x): # Flattens a list
    flattened_items = []
    for i in x:
        flattened_items.extend(x[i])
    return flattened_items

def findminterms(a): #Function for finding out which minterms are merged. For example, 10-1 is obtained by merging 9(1001) and 11(1011)
    gaps = a.count('-')
    if gaps == 0:
        return [str(int(a,2))]
    x = [bin(i)[2:].zfill(gaps) for i in range(pow(2,gaps))]
    temp = []
    for i in range(pow(2,gaps)):
        temp2,ind = a[:],-1
        for j in x[0]:
            if ind != -1:
                ind = ind+temp2[ind+1:].find('-')+1
            else:
                ind = temp2[ind+1:].find('-')
            temp2 = temp2[:ind]+j+temp2[ind+1:]
        temp.append(str(int(temp2,2)))
        x.pop(0)
    return temp

def compare(a,b): # Function for checking if 2 minterms differ by 1 bit only
    c = 0
    for i in range(len(a)):
        if a[i] != b[i]:
            mismatch_index = i
            c += 1
            if c>1:
                return (False,None)
    return (True,mismatch_index)

def removeTerms(_chart,terms): # Removes minterms which are already covered from chart
    for i in terms:
        for j in findminterms(i):
            try:
                del _chart[j]
            except KeyError:
                pass
def quine_mccluskey(mt):
  #mt = [int(i) for i in input("Enter the minterms: ").strip().split()]
  dc = []
  mt.sort()
  minterms = mt+dc
  minterms.sort()
  size = len(bin(minterms[-1]))-2
  groups,all_pi = {},set()

  # Primary grouping starts
  for minterm in minterms:
      try:
          groups[bin(minterm).count('1')].append(bin(minterm)[2:].zfill(size))
      except KeyError:
          groups[bin(minterm).count('1')] = [bin(minterm)[2:].zfill(size)]
  # Primary grouping ends

  # Process for creating tables and finding prime implicants starts
  while True:
      tmp = groups.copy()
      groups,m,marked,should_stop = {},0,set(),True
      l = sorted(list(tmp.keys()))
      for i in range(len(l)-1):
          for j in tmp[l[i]]: # Loop which iterates through current group elements
              for k in tmp[l[i+1]]: # Loop which iterates through next group elements
                  res = compare(j,k) # Compare the minterms
                  if res[0]: # If the minterms differ by 1 bit only
                      try:
                          groups[m].append(j[:res[1]]+'-'+j[res[1]+1:]) if j[:res[1]]+'-'+j[res[1]+1:] not in groups[m] else None # Put a '-' in the changing bit and add it to corresponding group
                      except KeyError:
                          groups[m] = [j[:res[1]]+'-'+j[res[1]+1:]] # If the group doesn't exist, create the group at first and then put a '-' in the changing bit and add it to the newly created group
                      should_stop = False
                      marked.add(j) # Mark element j
                      marked.add(k) # Mark element k
          m += 1
      local_unmarked = set(flatten(tmp)).difference(marked) # Unmarked elements of each table
      all_pi = all_pi.union(local_unmarked) # Adding Prime Implicants to global list
      #print("Unmarked elements(Prime Implicants) of this table:",None if len(local_unmarked)==0 else ', '.join(local_unmarked)) # Printing Prime Implicants of current table
      if should_stop: # If the minterms cannot be combined further
          break
      # Printing of all the next groups starts
      #print("\n\n\n\nGroup No.\tMinterms\tBinary of Minterms\n%s"%('='*50))
      #for i in sorted(groups.keys()):
        #  print("%5d:"%i) # Prints group number
         # for j in groups[i]:
        #      print("\t\t%-24s%s"%(','.join(findminterms(j)),j)) # Prints minterms and its binary representation
        #  print('-'*50)
      # Printing of all the next groups ends
  # Process for creating tables and finding prime implicants ends


  # Printing and processing of Prime Implicant chart starts
  sz = len(str(mt[-1])) # The number of digits of the largest minterm
  chart = {}
 # print('\n\n\nPrime Implicants chart:\n\n    Minterms    |%s\n%s'%(' '.join((' '*(sz-len(str(i))))+str(i) for i in mt),'='*(len(mt)*(sz+1)+16)))
  for i in all_pi:
      merged_minterms,y = findminterms(i),0
      #print("%-16s|"%','.join(merged_minterms),end='')
      for j in refine(merged_minterms,dc):
          x = mt.index(int(j))*(sz+1) # The position where we should put 'X'
          #print(' '*abs(x-y)+' '*(sz-1)+'X',end='')
          y = x+sz
          try:
              chart[j].append(i) if i not in chart[j] else None # Add minterm in chart
          except KeyError:
              chart[j] = [i]
      #print('\n'+'-'*(len(mt)*(sz+1)+16))
  # Printing and processing of Prime Implicant chart ends

  EPI = findEPI(chart) # Finding essential prime implicants
  #print("\nEssential Prime Implicants: "+', '.join(str(i) for i in EPI))
  removeTerms(chart,EPI) # Remove EPI related columns from chart

  if(len(chart) == 0): # If no minterms remain after removing EPI related columns
      final_result = [findVariables(i) for i in EPI] # Final result with only EPIs
  else: # Else follow Petrick's method for further simplification
      P = [[findVariables(j) for j in chart[i]] for i in chart]
      while len(P)>1: # Keep multiplying until we get the SOP form of P
          P[1] = multiply(P[0],P[1])
          P.pop(0)
      final_result = [min(P[0],key=len)] # Choosing the term with minimum variables from P
      final_result.extend(findVariables(i) for i in EPI) # Adding the EPIs to final solution
  if(len(final_result) <= 8) : # Print all prime implicants
    print('Solution: F = '+' + '.join(''.join(i) for i in final_result))
    print("\nAll Prime Implicants: ",None if len(all_pi)==0 else ', '.join(all_pi)) # Print all prime implicants
    return True
  else:
    return False
    
    
    

l= gen_number(49 , 20) #(number of signatures, bit widths)
